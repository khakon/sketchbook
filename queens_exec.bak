#lang racket
(require racket/trace)

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(trace-define (queen board-size)
              (define (queen-cols k)
                (if (= k 0)
                    (list empty-board)
                    (filter
                     (lambda (positions) (safe? k positions))
                     (flatmap
                      (lambda (rest-of-queens)
                        (map (lambda (new-row)
                               (adjoin-position new-row k rest-of-queens))
                             (enumerate-interval 1 board-size)))
                      (queen-cols (- k 1))))))
              (trace queen-cols)
              (queen-cols board-size))

(define empty-board '())

(define (adjoin-position row col rest-of-queens)
  (cons (list row col) rest-of-queens))

(define (safe? k positions)
  (if (= (length positions) 1)
      #t
      (if (attack? (k-queen positions) (first-queen positions))
          #f
          (safe? k (remove (first-queen positions) positions)))))

(define (k-queen positions)
  (car positions))

(define (first-queen positions)
  (cadr positions))

(define (attack? q1 q2)
  (or (= (row q1) (row q2))
      (= (abs (- (row q1) (row q2)))
         (abs (- (col q1) (col q2))))))
         
(define (row position)
  (car position))

(define (col position)
  (cadr position))

(define (remove item sequence)
  (filter (lambda (x) (not (equal? x item)))
          sequence))